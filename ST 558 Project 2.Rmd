---
title: "Project 2"
author: "Rachel Hencher"
date: '2022-09-26'
output:
  html_document:
    toc: yes
    toc_float: yes
    theme: cerulean
    highlight: pygments
params:
  key: D3KHf387z9W0EaDoVZNsvD6aOSHPWZmwDvKpTxpr
  state: NC
  ordering: desc
  rows: 100
  year: latest
  ownership: private
  locale: town
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The goal for this project is to create a vignette about contacting an API using functions created to query, parse, and return well-structured data. Then, to use the functions to obtain data from the API and do some exploratory data analysis.  

In order to demonstrate these skills, we will contact the College Scorecard API from the US Department of Education. We will then create functions in order to return topic-specific data for a user interested in finding out information on colleges in the US. More specifically, we will create a function to provide general information on colleges in a particular state, a function to provide information on tuition and other incurred costs, a function to provide information on admissions rates and testing requirements, a function to provide demographic information on the student body, a function to provide student financial information, and a function to provide information on earnings of students ten years after entry.  

Although the College Scorecard API only has one endpoint, there are hundreds of possible mutations for this enormous set of data, several combinations of which are explored below. 

# Required Packages  
We must first install the necessary packages to contact our API and to then create graphics. The following packages were used:  

`tidyverse`: a collection of R packages that are designed to work together to allow us to read in, transform, and visualize data  
`httr`: allows us to use the `GET` function to access the API   
`jsonlite`: allows us to access the `fromJSON` function to convert JSON data to a data frame  
`ggplot2`: a package in the tidyverse that we will use for creating graphics  
`gridExtra`: allows us to arrange plots in a grid  
`forcats`: TBD
```{r, message=FALSE}
library(tidyverse)
library(httr)
library(jsonlite)
library(ggplot2)
library(gridExtra)
library(forcats)
```

# Functions  
Each of the functions below will contact the College Scorecard API and return well-formatted, parsed data in the form of data frames on the specified topics.  

## `general_info()`  
The following function returns general information on either the largest or smallest *n* colleges in a particular state. The variables returned were selected based on "typical" factors discussed when selecting a college.  
The user should provide input for five arguments:  
- `key` requests the user's personal key to access the API  
- `state` requests which state the user would like to retrieve info for using the 2-character abbreviation for the state  
- `size` requests whether the user would like data on large or small schools by selecting "desc" or "asc" respectively  
- `n` is the number of records returned (1-100)  
- `year` requests data from a particular year if the user desires data other than the latest available
```{r}
general_info <- function(key="D3KHf387z9W0EaDoVZNsvD6aOSHPWZmwDvKpTxpr", state="NC", size="desc", n=50, year="latest")
{
  url <- paste0("http://api.data.gov/ed/collegescorecard/v1/schools?api_key=", key, "&school.state=", state, "&per_page=", n, "&sort=student.size:", size, "&_fields=school.name,school.ownership,", year, ".student.size,", year, ".admissions.admission_rate.overall,", year, ".cost.tuition.in_state,", year, ".cost.tuition.out_of_state")

  data <- GET(url)
  
  parsed_data <- fromJSON(rawToChar(data$content))
  
  parsed_data$results$school.ownership <- as.factor(parsed_data$results$school.ownership)
        levels(parsed_data$results$school.ownership) <- c("Public", "Private, Nonprofit", "Proprietary")
  
  general_data <-
    parsed_data$results %>%
    as_tibble() %>%
    select("Name"=ends_with("name"), 
    "Ownership"=ends_with("ownership"), 
    "Size"=ends_with("size"), 
    "Admissions_Rate"=ends_with("overall"), 
    "In_State_Tuition"=ends_with("in_state"), 
    "Out_of_State_Tuition"=ends_with("out_of_state"))

  return(general_data)
}
```
*In order to create the function above, we first set up our arguments to allow the user to return a more customized set of data. Defaults were set to our personal access key for the College Scorecard API, our home state of NC, descending results by college size, 50 entries to be returned, and the latest information available through the API. We then utilized the `paste0` function in order to incorporate these arguments into the URL call. The `GET` function allows us to then call the URL and the `fromJSON` function allows us to read the JSON-formatted content into R. We then saved just the "results" portion of our data, excluding the metadata information, as a tibble using the `as_tibble` function and used `select` to order and rename the variables. Utilizing `ends_with` enabled us to rename the variables more efficiently without having to type out the lengthy default name. Finally, we used the `as.factor` function to create descriptions for the various levels of the "ownership" variable that add context to our variable, instead of simple numeric coding. This new tibble is then designated as our object to be returned for this function.*  

## `cost_info()`  
The following function returns cost information on either the most or least expensive *n* colleges in a particular state by in-state tuition. Variables such as in-state & out-of-state tuition, in addition to books & room & board are included.  
The user should provide input for five arguments:  
- `key` requests the user's personal key to access the API  
- `state` requests which state the user would like to retrieve info for using the 2-character abbreviation for the state  
- `cost` requests whether the user would like data on expensive or more affordable schools by selecting "desc" or "asc" respectively  
- `n` is the number of records returned (1-100)  
- `year` requests data from a particular year if the user desires data other than the latest available
```{r}
cost_info <- function(key="D3KHf387z9W0EaDoVZNsvD6aOSHPWZmwDvKpTxpr", state="NC", cost="desc", n=50, year="latest")
{
  url <- paste0("http://api.data.gov/ed/collegescorecard/v1/schools?api_key=", key, "&school.state=", state, "&per_page=", n, "&sort=cost.tuition.in_state:", cost, "&_fields=school.name,school.ownership,", year, ".cost.tuition.in_state,", year, ".cost.tuition.out_of_state,", year, ".cost.booksupply,", year, ".cost.roomboard.oncampus,", year, ".cost.roomboard.offcampus")

  data <- GET(url)
  
  parsed_data <- fromJSON(rawToChar(data$content))

  cost_data <-
    parsed_data$results %>%
    as_tibble() %>%
    select("Name"=ends_with("name"), 
    "Ownership"=ends_with("ownership"), 
    "In_State_Tuition"=contains("in"), 
    "Out_of_State_Tuition"=contains("out"), 
    "Books_Supplies"=ends_with("supply"), 
    "Room_Board_On"=ends_with("oncampus"), 
    "Room_Board_Off"=ends_with("offcampus"))
  
    cost_data$Ownership <- as.factor(cost_data$Ownership)
      levels(cost_data$Ownership) <- c("Public", "Private, Nonprofit", "Proprietary")
      
  return(cost_data)
}
```
*In order to create the function above, we again start by setting up our arguments to allow the user to return a more customized set of data. Defaults were set to our personal access key for the College Scorecard API, our home state of NC, descending results by in-state tuition costs, 50 entries to be returned, and the latest information available through the API. We again utilized the `paste0` function in order to incorporate these arguments into the URL call. The `GET` function allows us to again call the URL and the `fromJSON` function allows us to read the JSON-formatted content into R. We then saved just the "results" portion of our data, excluding the metadata information, as a tibble using the `as_tibble` function and used `select` to order and rename the variables. `ends_with` is once again utilized to rename the variables more efficiently. Finally, we used the `as.factor` function to again create more informative descriptions for the various levels of the "ownership" variable. This new tibble is then designated as our object to be returned for this function.*  

## `admissions_info()`  
The following function returns admissions info on *n* colleges under a particular "ownership" category. The selected variables allow the user to explore admissions rates and testing scores & requirements.  
The user should provide input for five arguments:  
- `key` requests the user's personal key to access the API  
- `ownership` requests whether the user would like to retrieve admissions info for "public", "private" (nonprofit), or "proprietary" colleges  
- `rate` requests whether the user would like data on less competitive or more selective schools by selecting "desc" or "asc" respectively  
- `n` is the number of records returned (1-100)  
- `year` requests data from a particular year if the user desires data other than the latest available
```{r}
admissions_info <- function(key="D3KHf387z9W0EaDoVZNsvD6aOSHPWZmwDvKpTxpr", ownership="private", rate="asc", n=50, year="latest")
{
  ownership <- ifelse(tolower(ownership)=="public", "1", 
                      ifelse(tolower(ownership)=="private", "2", 
                             ifelse(tolower(ownership)=="proprietary", "3", "ERROR"))) 
        
  url <- paste0("http://api.data.gov/ed/collegescorecard/v1/schools?api_key=", key, "&school.ownership=", ownership, "&per_page=", n, "&sort=admissions.admission_rate.overall:", rate, "&school.degrees_awarded.predominant=3&_fields=school.name,", year, ".admissions.admission_rate.overall,", year, ".admissions.test_requirements,", year, ".admissions.sat_scores.midpoint.critical_reading,", year, ".admissions.sat_scores.midpoint.writing,", year, ".admissions.sat_scores.midpoint.math,", year, ".admissions.act_scores.midpoint.english,", year, ".admissions.act_scores.midpoint.writing,", year, ".admissions.act_scores.midpoint.math")

  data <- GET(url)
  
  parsed_data <- fromJSON(rawToChar(data$content))
  
  admissions_data <-
    parsed_data$results %>%
    as_tibble() %>%
    select("Name"=ends_with("name"), 
    "Ownership"=ends_with("ownership"), 
    "Admissions_Rate"=ends_with("overall"), 
    "Test_Requirements"=ends_with("requirements"), 
    "SAT_Reading"=ends_with("reading"), 
    "SAT_Writing"=ends_with("sat_scores.midpoint.writing"), 
    "SAT_Math"=ends_with("sat_scores.midpoint.math"), 
    "ACT_English"=ends_with("english"), 
    "ACT_Writing"=ends_with("act_scores.midpoint.writing"), 
    "ACT_Math"=ends_with("act_scores.midpoint.math"))
    
    admissions_data$Test_Requirements <- as.factor(admissions_data$Test_Requirements)
      levels(admissions_data$Test_Requirements) <- c("Required", "Recommended", "Neither required nor recommended", "Do not know", "Considered but not required")
  
  return(admissions_data)
}
```
*In order to create the function above, we use a similar process as with the previous two functions; however, after setting the default input for each argument, we start by using a series of `ifelse` functions to make the input for "ownership" more user-friendly. We first set up an `ifelse` statement specifying that if the user designates "public" for the input, then we would be looking to see whether the ownership status is a "1" in the data set. We then use an additional `ifelse` function to indicate that if the ownership status is not "1" (i.e. "FALSE"), we investigate whether it is true or false that the ownership status is "2". We then use one additional `ifelse` statement to investigate whether the ownership status is "3", designating that an error message should appear if it is neither a "1", "2", or a "3". In conjunction with the `ifelse` function, we use `tolower` in order to allow the user to type in the ownership status without worrying about capitalization. The steps that follow are then identical to those in the functions above... We use the `GET` and `fromJSON` functions to retrieve the data. We then convert it to a tibble and reorder and rename the variables. This time; however, we are using the `as.factor` function to create more contextual descriptions for the variable called "Admissions Requirements". This variable was previously displaying a numeric code, but we were able to designate better descriptions for each level using information provided on the College Scorecard website.*  

## `demographic_info()`  
The following function returns demographic information for students at *n* colleges, selected based on the location type. Race & ethnicity are the primary variables explored.  
The user should provide input four arguments:  
- `key` requests the user's personal key to access the API  
- `locale` requests whether the user would like to retrieve demographic info for colleges in a "city", "suburb", "town" or "rural" location  
- `size` requests whether the user would like data on large or small schools by selecting "desc" or "asc" respectively    
- `n` is the number of records returned (1-100)
```{r}
demographic_info <- function(key="k42psBgICW3DEe6eS1gc7AxbTTYtOwOGN9URGVuT", state = "NC", size = "asc", locale="town", n=50, year= "latest")
{
  location <- ifelse(locale=="city", "11,12,13", 
                     ifelse(locale=="suburb", "21,22,23",
                            ifelse(locale=="town", "31,32,33",
                                   ifelse(locale=="rural", "41,42,43", "ERROR"))))
  
    url <- paste0("http://api.data.gov/ed/collegescorecard/v1/schools?api_key=", key, "&school.state=", state, "&school.locale=", location, "&per_page=", n, "&sort=student.size:", size, "&_fields=school.name,school.ownership,school.city,", year, ".student.size,", year, ".student.demographics.race_ethnicity.aian,", year, ".student.demographics.race_ethnicity.nhpi,", year, ".student.demographics.race_ethnicity.asian,", year, ".student.demographics.race_ethnicity.black,", year, ".student.demographics.race_ethnicity.white,", year, ".student.demographics.race_ethnicity.hispanic,", year, ".student.demographics.race_ethnicity.unknown,", year, ".student.demographics.men,", year, ".student.demographics.women")
  
  data <- GET(url)
  
  parsed_data <- fromJSON(rawToChar(data$content))
  
  demographic_data <-
    parsed_data$results %>%
    as_tibble() %>%
    select("Name"=ends_with("name"),
           "City"=ends_with("city"),
           "Ownership"=ends_with("ownership"),
           "Total_Enrollment"=ends_with("size"),
           "AIAN"=ends_with("aian"),
           "NHPI"=ends_with("nhpi"),
           "Asian"=ends_with("asian"),
           "Black"=ends_with("black"),
           "White"=ends_with("white"),
           "Hispanic"=ends_with("hispanic"),
           "Unknown"=ends_with("unknown"),
           "Men"=ends_with("men"),
           "Women"=ends_with("women"))
  
      demographic_data$Ownership <- as.factor(demographic_data$Ownership)
        levels(demographic_data$Ownership) <- c("Public", "Private, Nonprofit", "Proprietary")
  
    demographic_data <- demographic_data %>% 
      mutate(Total_AIAN=round(Total_Enrollment*AIAN), 
             Total_NHPI=round(Total_Enrollment*NHPI), 
             Total_Asian=round(Total_Enrollment*Asian), 
             Total_Black=round(Total_Enrollment*Black),
             Total_White=round(Total_Enrollment*White), 
             Total_Hispanic=round(Total_Enrollment*Hispanic),
             Total_Unknown=round(Total_Enrollment*Unknown),
             Total_Men=round(Total_Enrollment*Men1),
             Total_Women=round(Total_Enrollment*Women)) %>% 
      select(Name, City, Ownership, starts_with("Total_")) %>% 
      pivot_longer(cols=!c(Name, City, Ownership), names_to="Ethnicity_Gender", values_to="Count") 
  
  return(demographic_data)
}
```
*In order to create the function above, we begin with the same strategy as with the previous function. However, instead of making the input for the ownership variable more user-friendly, we use `ifelse` statements to make the input for the "locale" variable more user-friendly. The steps that follow are then identical to those in all of the functions above... We use the `GET` and `fromJSON` functions to retrieve the data. We then convert it to a tibble with the `as_tibble` function and reorder and rename the variables with the `select` function. We then once again use the `as.factor` function to create more contextual descriptions for the variable called "Ownership". This variable was previously displaying a numeric code, but we were able to designate better descriptions for each level using information provided on the College Scorecard website. Next, we use the `mutate` function to create new variables to display the total number of students for a particular demographic, instead of just the proportion. We the use `pivot_longer` to take the wide-format data and to convert it to long-format data. Finally, we indicate that we would like to return this new data frame.*  

## `financial_info()`  
The following function returns student financial information on either the largest or smallest *n* colleges in a particular state. Variables selected include median family income, poverty rate, and student debt. 
The user should provide input for five arguments:  
- `key` requests the user's personal key to access the API  
- `state` requests which state the user would like to retrieve info for using the 2-character abbreviation for the state  
- `size` requests whether the user would like data on large or small schools by selecting "desc" or "asc" respectively  
- `n` is the number of records returned (1-100)  
- `year` requests data from a particular year if the user desires data other than the latest available
```{r}
financial_info <- function(key="D3KHf387z9W0EaDoVZNsvD6aOSHPWZmwDvKpTxpr", state="NC", size="desc", n=50, year="latest")
{
  url <- paste0("http://api.data.gov/ed/collegescorecard/v1/schools?api_key=", key, "&school.state=", state, "&per_page=", n, "&sort=student.size:", size, "&_fields=school.name,school.ownership,school.city,", year, ".student.size,", year, ".student.demographics.poverty_rate,", year, ".student.demographics.median_family_income,", year, ".aid.median_debt.female_students,", year, ".aid.median_debt.male_students")

  data <- GET(url)
  
  parsed_data <- fromJSON(rawToChar(data$content))
  
  financial_data <- 
    parsed_data$results %>%
    as_tibble() %>%

    select("Name"=ends_with("name"), 
    "Ownership"=ends_with("ownership"), 
    "City"=ends_with("city"), 
    "Size"=ends_with("size"), 
    "Poverty_Rate"=ends_with("poverty_rate"), 
    "Median_Family_Income"=ends_with("income"), 
    "Female_Median_Debt"=ends_with("female_students"), 
    "Male_Median_Debt"=ends_with("debt.male_students"))
  
    financial_data$Ownership <- as.factor(financial_data$Ownership)
      levels(financial_data$Ownership) <- c("Public", "Private, Nonprofit", "Proprietary")

  return(financial_data)
}
```
*In order to create the function above, we again start by setting up our arguments to allow the user to return a more customized set of data. Defaults were set to our personal access key for the College Scorecard API, our home state of NC, descending results by school size, 50 entries to be returned, and the latest information available through the API. We again utilized the `paste0` function in order to incorporate these arguments into the URL call. The `GET` function allows us to again call the URL and the `fromJSON` function allows us to read the JSON-formatted content into R. We then saved just the "results" portion of our data, excluding the metadata information, as a tibble using the `as_tibble` function and used `select` to order and rename the variables. `ends_with` is once again utilized to rename the variables more efficiently. Finally, we used the `as.factor` function to again create more informative descriptions for the various levels of the "ownership" variable. This new tibble is then designated as our object to be returned for this function.*  

## `earnings_info()`  
The following function returns earnings information on *n* colleges with either the highest or lowest median student earnings 10 years after entry.  In addition to returning a variable for median earnings, variables for mean earnings by gender are also included. Finally, tuition costs are included in this data frame so that the user may draw comparisions between cost and future earnings.  
The user should provide input for four arguments:  
- `key` requests the user's personal key to access the API  
- `earnings` requests whether the user would like data on schools whose students are the highest earners or lowest earners by selecting "desc" or "asc" respectively  
- `n` is the number of records returned (1-100)  
- `year` requests data from a particular year if the user desires data other than the latest available
```{r}
earnings_info <- function(key="D3KHf387z9W0EaDoVZNsvD6aOSHPWZmwDvKpTxpr", earnings="desc", n=50, year="latest")
{
  url <- paste0("http://api.data.gov/ed/collegescorecard/v1/schools?api_key=", key, "&per_page=", n, "&sort=earnings.10_yrs_after_entry.median:", earnings, "&school.degrees_awarded.predominant=3&_fields=school.name,", year, ".cost.tuition.in_state,", year, ".cost.tuition.out_of_state,", year, ".earnings.10_yrs_after_entry.median,", year, ".earnings.10_yrs_after_entry.mean_earnings.female_students,", year, ".earnings.10_yrs_after_entry.mean_earnings.male_students")

  data <- GET(url)
  parsed_data <- fromJSON(rawToChar(data$content))

  earnings_data <-
    parsed_data$results %>%
    as_tibble() %>%
    select("Name"=ends_with("name"), 
    "In_State_Tuition"=ends_with("in_state"), 
    "Out_of_State_Tuition"=ends_with("out_of_state"), 
    "Median_Earnings"=ends_with("median"), 
    "Mean_For_Females"=ends_with("female_students"), 
    "Mean_For_Males"=ends_with("mean_earnings.male_students"))

  return(earnings_data)
}
```
*In order to create this final function above, we again start by setting up our arguments to allow the user to return a more customized set of data. Defaults were set to our personal access key for the College Scorecard API, descending results by earnings 10 years after entry, 50 entries to be returned, and the latest information available through the API. We again utilized the `paste0` function in order to incorporate these arguments into the URL call. The `GET` function allows us to again call the URL and the `fromJSON` function allows us to read the JSON-formatted content into R. We then saved just the "results" portion of our data, excluding the metadata information, as a tibble using the `as_tibble` function and used `select` to order and rename the variables. `ends_with` is once again utilized to rename the variables more efficiently. This new tibble is then, once again, designated as our object to be returned for this function.*  

# Data Exploration
```{r, warning=FALSE, include=TRUE, echo=TRUE}
exploration <- function(general_data, cost_data, admissions_data, demographic_data, financial_data, earnings_data, state, locale) {

# Summary table of data generated within the general_info function
general_summary <- summary(general_data)

# Boxplot of Size by Ownership for data generated within the general_info function  
size_by_ownership <- ggplot(general_data, aes(x=Ownership, y=Size)) + 
  geom_boxplot(fill = "#112446") + 
  labs(title="Size by Ownership Type for State Colleges") + 
  theme_minimal()

# Scatterplot of Admissions Rate vs In-State Tuition for data generated within the general_info function
instate_vs_adm <- ggplot(general_data, aes(x=Admissions_Rate, y=In_State_Tuition)) + 
  geom_point(aes(color=Ownership)) + 
  labs(x="Admissions Rate", y="In-State Tuition", title="In-State Tuition vs Admissions Rate for State Colleges") + 
  theme_minimal()

# Scatterplot of Admissions Rate vs Out-of-State Tuition for data generated within the general_info function
outstate_vs_adm <- ggplot(general_data, aes(x=Admissions_Rate, y=Out_of_State_Tuition)) + 
  geom_point(aes(color=Ownership)) + 
  labs(x="Admissions Rate", y="Out-of-State Tuition", title="Out-of-State Tuition vs Admissions Rate for State Colleges") + 
  theme_minimal()
  
# Addition of Total SAT and Total ACT variables to data generated within the admissions_info function
admissions_data2 <- admissions_data %>%
  mutate("Total_SAT"=(sumrow=SAT_Reading+SAT_Math), "Total_ACT"=(sumrow=ACT_English+ACT_Math))

# Scatterplot of Admissions Rate vs Total SAT with a regression line overlaid for data generated within the admissions_info function
sat_vs_adm <- ggplot(admissions_data2, aes(x=Admissions_Rate, y=Total_SAT)) + 
  geom_point(aes(shape=Test_Requirements, color=Test_Requirements)) + 
  geom_smooth(method=lm) + labs(x="Admissions Rate", y="Total SAT for Reading/Math", title="Total SAT Score vs Admissions Rate for US Colleges") + 
  theme_minimal()

# Scatterplot of Admissions Rate vs Total ACT with a regression line overlaid for data generated within the admissions_info function
act_vs_adm <- ggplot(admissions_data2, aes(x=Admissions_Rate, y=Total_ACT)) + 
  geom_point(aes(shape=Test_Requirements, color=Test_Requirements)) + 
  geom_smooth(method=lm) + 
  labs(x="Admissions Rate", y="Total ACT for English/Math", title="Total ACT Score vs Admissions Rate for US Colleges") + 
  theme_minimal()

# Scatterplot of Total SAT vs Total ACT with a regression line overlaid for data generated within the admissions_info function
act_vs_sat <- ggplot(admissions_data2, aes(x=Total_SAT, y=Total_ACT)) + 
  geom_point(aes(shape=Test_Requirements, color=Test_Requirements)) + 
  geom_smooth(method=lm) + 
  labs(x="Total SAT for Reading/Math", y="Total ACT for English/Math", title="Total ACT Score vs Total SAT Score for US Colleges") + 
  theme_minimal()

# Boxplot of Ownership by In-State Tuition with points overlaid for data generated within the cost_info function
instate_by_ownership <- ggplot(cost_data, aes(x=Ownership, y=In_State_Tuition)) + 
  geom_boxplot(fill="#112446") + 
  scale_y_continuous(trans="log10") + 
  geom_jitter() +
  labs(y="In-State Tuition", title="In-State Tuition by Ownership Type for State Colleges") + 
  theme_minimal()

# Boxplot of Ownership by Out-of-State Tuition with points overlaid for data generated within the cost_info function
outstate_by_ownership <- ggplot(cost_data, aes(x=Ownership, y=Out_of_State_Tuition)) + 
  geom_boxplot(fill="#112446") + 
  scale_y_continuous(trans="log10") + 
  geom_jitter() +
  labs(y="Out-of-State Tuition", title="Out-of-State Tuition by Ownership Type for State Colleges") + 
  theme_minimal()

# SNEHA TO ADD
demographic_data_race <- demographic_data %>% 
  filter(!(Ethnicity_Gender %in% c("Total_Men", "Total_Women")), !(Ownership %in% "Proprietary")) %>% 
  group_by(Ownership, Ethnicity_Gender) %>% 
  summarise(Total_Count=sum(Count)) %>% 
  arrange(Total_Count, .by_group = TRUE)

# SNEHA TO ADD
demographic_ownership <- demographic_data_race %>% 
  filter(!(Ethnicity_Gender %in% "Total_Enrollment")) %>%
  arrange(Ethnicity_Gender) %>% 
  ggplot(aes(x=Ownership, y=Total_Count, fill=Ethnicity_Gender)) +
  geom_bar(position=position_dodge2(reverse=TRUE), stat='identity') +
  scale_fill_hue(direction=1) +
  labs(
    x="Ownership",
    y="Total Student Count",
    title="Undergraduate Students enrolled for each Ownership by Ethnicity",
    subtitle=paste("State :", state, "; Locale :", locale)
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) 

# SNEHA TO ADD
demographic_data_gender <- demographic_data %>% 
  filter(Ethnicity_Gender %in% c("Total_Men", "Total_Women")) %>% 
  ggplot(aes(x=Ownership, y=Count, fill=Ethnicity_Gender)) +
  geom_boxplot() +
  scale_y_continuous(trans="log10") +
  labs(
    x="Ownership",
    y="Count",
    title="Count of Students for each Ownership by Gender",
    subtitle=paste("State :", state, "; Locale :", locale)
  ) + 
  theme_minimal() +
  theme(plot.title=element_text(hjust=0.5),
        plot.subtitle=element_text(hjust=0.5)) 
  

financial_poverty_rate <- financial_data %>% 
  group_by(Ownership, City) %>% 
  summarise(Median_Poverty_Rate=median(Poverty_Rate, na.rm=TRUE)) %>%
  filter(!is.na(Median_Poverty_Rate)) %>%
  ggplot() +
  aes(x=Median_Poverty_Rate, y=..density..) +
  geom_histogram(bins=6L, fill="#112446") +
  geom_density(color="red", 
               size=2) +
  labs(
    x="Poverty Rate",
    title="Poverty Rate Distribution by State"
  ) +
  theme_minimal() +
  theme(plot.title=element_text(hjust = 0.5),
        plot.subtitle=element_text(hjust = 0.5)) 

poverty_rate_by_ownership <- financial_data %>% 
  group_by(Ownership) %>% 
  summarise(Mean_PR = mean(Poverty_Rate, na.rm=TRUE)) %>% 
  filter(!(Ownership %in% "Proprietary")) %>% 
  ggplot() +
  aes(x=Ownership, y=Mean_PR) +
  geom_col(fill="#112446") +
  labs(
    x="Poverty Rate",
    title="Poverty Rate by Ownership for Each State"
  ) +
  theme_minimal() +
  theme(plot.title=element_text(hjust = 0.5),
        plot.subtitle=element_text(hjust = 0.5)) 

instate_earning <- ggplot(earnings_data) +
  aes(x=In_State_Tuition, y=Median_Earnings) +
  geom_point(shape="circle", size=2, colour="#112446") +
  geom_smooth(span=0.75) +
  theme_minimal() +
  theme(plot.title=element_text(hjust=0.5),
        plot.subtitle=element_text(hjust=0.5)) 

outstate_earning <-  ggplot(earnings_data) +
  aes(x=Out_of_State_Tuition, y=Median_Earnings) +
  geom_point(shape="circle", size=2, colour="#112446") +
  geom_smooth(span=0.75) +
  theme_minimal() +
  theme(plot.title=element_text(hjust=0.5),
        plot.subtitle=element_text(hjust=0.5)) 

return(list(general_summary, size_by_ownership, instate_vs_adm, outstate_vs_adm, sat_vs_adm, act_vs_adm, act_vs_sat, instate_by_ownership, outstate_by_ownership, demographic_data_race, demographic_ownership, demographic_data_gender, financial_poverty_rate, poverty_rate_by_ownership, instate_earning, outstate_earning))
}
```
*For each of the graphics above, we begin with the `ggplot` function to create a coordinate system from which we can then build. We next add a "geom_function" such as `geom_bar`, `geom_point`, or `geom_smooth` in order to add the specified layer to our coordinate system. ADD HERE FOR DETAILS. We next use `labs` in order to add more informative and descriptive plot titles, axis labels, and key titles. THEME*


# Main Function  
In order for the user to pull all of the information at once with one set of inputs, use the "Main Function" created below.  
Take the user input of:  

- state
- ordering 
- rows 
- year 
- ownership 
- locale

```{r, warning=FALSE, include=TRUE, echo=TRUE}
main <- function() {
  key = params$key
  state = params$state
  size = params$ordering
  n = params$rows 
  year = params$year
  ownership = params$ownership
  locale = params$locale
  general_data <- general_info(key, state, size, n, year)
  cost_data <- cost_info(key, state, cost = size, n, year)
  admissions_data <- admissions_info(key, ownership, rate=size, n, year)
  demographic_data <- demographic_info(key, state, size, locale, n, year)
  financial_data <- financial_info(key, state, size, year)
  earnings_data <- earnings_info(key, earnings = size, n, year)
  exploration(general_data, cost_data, admissions_data, demographic_data, financial_data, earnings_data, state, locale)
}
```
*The function created above allows the user to provide input for the set of parameters just one time at the very top of the code and then applies those choices to all of the previous functions discussed. For instance, this makes it easy for a user who is interested in staying in a particular state to research varying topics on colleges just in the state of interest. It also makes it easy to pull data for a specific year without having to type it as an argument into each separate function.*  

```{r, warning=FALSE, include=TRUE, echo=TRUE}
result_list <- main()
for( i in 1:length(result_list)){
  if(i == length(result_list)){
    outstate_earning = result_list[[i]]
  }
  else if(i == (length(result_list)-1)){
    instate_earning = result_list[[i]]
  }
  else{
  print(result_list[[i]])
  }
}
grid.arrange(instate_earning, outstate_earning, ncol=2)
```
